import * as dotenv from "dotenv";
import * as fs from "fs";
import * as path from "path";
import prettier from "prettier";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const ROOT_DIR = path.resolve(__dirname, "..");
const SRC_DIR = path.resolve(ROOT_DIR, "src");

if (!fs.existsSync(SRC_DIR)) {
    throw new Error(`❌ unable to find /src dir`);
}

const ENV_FILE_PREFIX = ".env.";

const allowedDotEnvTypes = [String, Number, Boolean] as const;
const dotEnvTypeNames: string[] = allowedDotEnvTypes.map((type_) => type_.name);
const regexKeyEmbeddedType = getRegexFromDotEnvTypes(dotEnvTypeNames);

// something like: string | number
type TAllowedDotEnvTypes = (typeof allowedDotEnvTypes)[number] extends new (
    ...args: any[]
) => infer ReturnType
    ? ReturnType
    : never;

const allDotenvFilenames = getDotenvFileBaseNames();
await createDotenvTypesFile(allDotenvFilenames);
await createAllDotEnvFiles(allDotenvFilenames);

// functions

async function createDotenvTypesFile(
    allDotenvFilenames: string[],
): Promise<void> {
    let mergedDotenvConfigs = {};
    for (const dotenvFilename of allDotenvFilenames) {
        const parsedDotenvConfig = loadDotenvFile(dotenvFilename);
        mergedDotenvConfigs = mergeDotEnvConfigs(
            mergedDotenvConfigs,
            parsedDotenvConfig,
        );
    }
    const typedDotEnvConfig: Record<string, TAllowedDotEnvTypes> =
        getTypedDotEnv(mergedDotenvConfigs);

    const dotenvTypesTsContent = `export type TProcessEnv = {
${dotenv2TsTypes(typedDotEnvConfig)}
}`;
    const outputFile: string = path.resolve(SRC_DIR, `dotenv.d.ts`);
    fs.writeFileSync(outputFile, await prettyTS(dotenvTypesTsContent), "utf8");
    console.log(`✅ ${outputFile} has been generated.`);
}

async function createAllDotEnvFiles(
    allDotenvFilenames: string[],
): Promise<void> {
    for (const dotenvFilename of allDotenvFilenames) {
        await createDotEnvFile(dotenvFilename);
    }
}

async function createDotEnvFile(dotenvFilename: string): Promise<void> {
    const parsedDotenvConfig = loadDotenvFile(dotenvFilename);

    const typedDotEnvConfig: Record<string, TAllowedDotEnvTypes> =
        getTypedDotEnv(parsedDotenvConfig);

    const outputFileWithPath = path.resolve(
        SRC_DIR,
        getDotenvTsFilename(dotenvFilename),
    );
    const dotenvEnvironmentVarName = getEnvironmentVarName(dotenvFilename);
    const dotenvTsContent =
        `
// this file was autogenerated by generate-dotenv.ts
// do not edit this file. instead edit ${dotenvFilename} then rerun generate-dotenv.ts

import type { TProcessEnv } from "./dotenv.d.ts";

export const ${dotenvEnvironmentVarName}Env: Partial<TProcessEnv> = ` +
        JSON.stringify(typedDotEnvConfig) +
        `;`;

    fs.writeFileSync(
        outputFileWithPath,
        await prettyTS(dotenvTsContent),
        "utf8",
    );
    console.log(`✅ ${outputFileWithPath} has been generated.`);
}

/** the types of the variable are stored on the end of the .env key.
 * eg. MY_VAR_NUMBER */
function getRegexFromDotEnvTypes(allowedDotEnvTypes: string[]): RegExp {
    const typesAsString: string = allowedDotEnvTypes
        .map((typeName: string) => typeName.toUpperCase())
        .join("|");

    return new RegExp(`_(${typesAsString})$`);
}

function loadDotenvFile(dotenvFile: string): dotenv.DotenvParseOutput {
    const dotEnvFilePath: string = path.resolve(ROOT_DIR, dotenvFile);

    if (!fs.existsSync(dotEnvFilePath)) {
        throw new Error(
            `❌ unable to load ${dotenvFile}. file not found at ${dotEnvFilePath}`,
        );
    }

    const dotenvConfig: dotenv.DotenvConfigOutput = dotenv.config({
        path: dotEnvFilePath,
    });

    if (dotenvConfig.error) {
        throw new Error(
            `❌ Error parsing ${dotenvFile} file: ` +
                `${dotenvConfig.error.message}`,
        );
    }

    const parsedDotenvVars: dotenv.DotenvParseOutput | undefined =
        dotenvConfig.parsed;
    if (parsedDotenvVars == null) {
        throw new Error(
            `❌ Error parsing ${dotenvFile} file: no variables found`,
        );
    }
    return parsedDotenvVars;
}

/** later config args overwrite earlier config args */
function mergeDotEnvConfigs(
    ...dotEnvConfigs: (dotenv.DotenvParseOutput | undefined)[]
): dotenv.DotenvParseOutput {
    return dotEnvConfigs.reduce(
        (previous, current) =>
            current === undefined ? previous : { ...previous, ...current },
        {},
    )!;
}

function getDotenvTsFilename(dotenvFilename: string): string {
    const withoutLeadingDot = dotenvFilename.replace(`.env`, `env`);
    return `dot${withoutLeadingDot}.ts`;
}

function getTypedDotEnv(
    parsedDotenvVars: dotenv.DotenvParseOutput,
): Record<string, TAllowedDotEnvTypes> {
    return Object.keys(parsedDotenvVars).reduce<
        Record<string, TAllowedDotEnvTypes>
    >((acc, key) => {
        const { updatedKey, keyTypeNameUpper } = extractTypeFromKey(key);
        switch (keyTypeNameUpper) {
            case "BOOLEAN":
                acc[updatedKey] = getBoolean(key, parsedDotenvVars[key]);
                break;
            case "NUMBER":
                acc[updatedKey] = getNumber(key, parsedDotenvVars[key]);
                break;
            default:
            case "STRING":
                acc[updatedKey] = parsedDotenvVars[key]!;
                break;
        }
        return acc;
    }, {});
}

function extractTypeFromKey(key: string): {
    updatedKey: string;
    keyTypeNameUpper?: string;
} {
    const capturedGroups: RegExpExecArray | null =
        regexKeyEmbeddedType.exec(key);

    if (capturedGroups == null) {
        return { updatedKey: key };
    }

    const keyTypeNameUpper: string = capturedGroups[1];
    const updatedKey = key.replace(regexKeyEmbeddedType, "");
    return { updatedKey, keyTypeNameUpper };
}

function getBoolean(
    dotEnvKey: string,
    dotEnvValue: string | undefined,
): boolean {
    if (dotEnvValue?.toLowerCase() === "true") return true;
    if (dotEnvValue?.toLowerCase() === "false") return false;
    throw new Error(`❌ value for ${dotEnvKey} must be "true" or "false"`);
}

function getNumber(dotEnvKey: string, dotEnvValue: string | undefined): number {
    const errorMessage = `Value for ${dotEnvKey} must be a number`;
    if (dotEnvValue === undefined) throw new Error(`❌ ${errorMessage}`);
    const parsedNumber = Number(dotEnvValue);
    if (
        isNaN(parsedNumber) ||
        parsedNumber === Infinity ||
        parsedNumber === -Infinity
    ) {
        throw new Error(`❌ ${errorMessage}`);
    }
    return parsedNumber;
}

function dotenv2TsTypes(
    parsedDotenvVars: Record<string, TAllowedDotEnvTypes>,
): string {
    const processEnvTypes = Object.keys(parsedDotenvVars)
        .map((key: string) => `${key}?: ${typeof parsedDotenvVars[key]};`)
        .join("\n");

    return processEnvTypes;
}

function getDotenvFileBaseNames(): string[] {
    return fs
        .readdirSync(ROOT_DIR)
        .filter((f) => f.startsWith(ENV_FILE_PREFIX));
}

function getEnvironmentVarName(dotenvFilename: string): string {
    return dotenvFilename
        .replace(ENV_FILE_PREFIX, "")
        .toLowerCase()
        .replace(".secret", "Secret");
}

async function prettyTS(jsFileContent: string): Promise<string> {
    // needs to find .prettierrc or .editorconfig
    const prettierOptions = await prettier.resolveConfig(ROOT_DIR);
    if (prettierOptions == null) {
        throw new Error(`❌ failed to find any prettier options file`);
    }
    return await prettier.format(jsFileContent, {
        ...prettierOptions,
        parser: "typescript",
    });
}
