import * as dotenv from "dotenv";
import * as fs from "fs";
import * as path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const ROOT = path.resolve(__dirname, "..");
const SRC_DIR = path.resolve(ROOT, "src");

if (!fs.existsSync(SRC_DIR)) {
    throw new Error(`unable to find /src dir`);
}

const ENV_FILE_PREFIX = ".env.";

const allowedDotEnvTypes = [String, Number, Boolean] as const;
const dotEnvTypeNames: string[] = allowedDotEnvTypes.map((type_) => type_.name);
const regexKeyEmbeddedType = getRegexFromDotEnvTypes(dotEnvTypeNames);

// something like: string | number
type TAllowedDotEnvTypes = (typeof allowedDotEnvTypes)[number] extends new (
    ...args: any[]
) => infer ReturnType
    ? ReturnType
    : never;

const defaultDotEnvTypeUpper: TAllowedDotEnvTypes = "STRING";

const allDotenvFilenames = getDotenvFileBaseNames();
createDotenvTypesFile(allDotenvFilenames);
createAllDotEnvFiles(allDotenvFilenames);

// functions

function createDotenvTypesFile(allDotenvFilenames: string[]): void {
    let mergedDotenvConfigs = {};
    for (const dotenvFilename of allDotenvFilenames) {
        const parsedDotenvConfig = loadDotenvFile(dotenvFilename);
        mergedDotenvConfigs = mergeDotEnvConfigs(
            mergedDotenvConfigs,
            parsedDotenvConfig,
        );
    }
    const typedDotEnvConfig: Record<string, TAllowedDotEnvTypes> =
        getTypedDotEnv(mergedDotenvConfigs);

    const dotenvTypesTsContent = `export type TProcessEnv = {
${dotenv2TsTypes(typedDotEnvConfig)}
}`;
    const outputFile: string = `${SRC_DIR}/dotenv.d.ts`;
    fs.writeFileSync(outputFile, dotenvTypesTsContent, "utf8");
    console.log(`âœ… ${outputFile} has been generated.`);
}

function createAllDotEnvFiles(allDotenvFilenames: string[]): void {
    for (const dotenvFilename in allDotenvFilenames) {
        createDotEnvFile(dotenvFilename);
    }
}

function createDotEnvFile(dotenvFilename: string): void {
    const parsedDotenvConfig = loadDotenvFile(dotenvFilename);
    const outputFileWithPath = `${SRC_DIR}/${getDotenvTsFilename(dotenvFilename)}`;
    const dotenvEnvironment = getEnvironment(dotenvFilename);
    const dotenvTsContent =
        `
// this file was autogenerated by generate-dotenv.ts
// do not edit this file. instead edit ${dotenvFilename} then rerun generate-dotenv.ts

import type { TProcessEnv } from "./dotenv.d.ts";

export const ${dotenvEnvironment}Env: Partial<TProcessEnv> = ` +
        JSON.stringify(parsedDotenvConfig, null, 4) +
        `;`;

    fs.writeFileSync(outputFileWithPath, dotenvTsContent, "utf8");
    console.log(`${outputFileWithPath} has been generated.`);
}

/** the types of the variable are stored on the end of the .env key.
 * eg. MY_VAR_NUMBER */
function getRegexFromDotEnvTypes(allowedDotEnvTypes: string[]): RegExp {
    const typesAsString: string = allowedDotEnvTypes
        .map((typeName: string) => typeName.toUpperCase())
        .join("|");

    return new RegExp(`_(${typesAsString})$`);
}

function loadDotenvFile(
    dotenvFile: string,
    mustBePopulated: boolean = false,
): dotenv.DotenvParseOutput | undefined {
    const dotEnvFilePath: string = path.resolve(process.cwd(), dotenvFile);

    if (!fs.existsSync(dotEnvFilePath)) {
        console.log(
            `unable to load ${dotenvFile}. file not found at ${dotEnvFilePath}`,
        );
        return;
    }

    const dotenvConfig: dotenv.DotenvConfigOutput = dotenv.config({
        path: dotEnvFilePath,
    });

    if (dotenvConfig.error) {
        console.error(
            `Error parsing ${dotenvFile} file:`,
            dotenvConfig.error.message,
        );
        process.exit(1);
    }

    const parsedDotenvVars: dotenv.DotenvParseOutput | undefined =
        dotenvConfig.parsed;
    if (mustBePopulated && parsedDotenvVars === undefined) {
        console.error(`Error parsing ${dotenvFile} file: no variables found`);
        process.exit(1);
    }
    return parsedDotenvVars;
}

/** later config args overwrite earlier config args */
function mergeDotEnvConfigs(
    ...dotEnvConfigs: (dotenv.DotenvParseOutput | undefined)[]
): dotenv.DotenvParseOutput {
    return dotEnvConfigs.reduce(
        (previous, current) =>
            current === undefined ? previous : { ...previous, ...current },
        {},
    )!;
}

function getDotenvTsFilename(dotenvFilename: string): string {
    const withoutLeadingDot = dotenvFilename.replace(`.env`, `env`);
    return `dot${withoutLeadingDot}.ts`;
}

function getTypedDotEnv(
    parsedDotenvVars: NodeJS.ProcessEnv,
): Record<string, TAllowedDotEnvTypes> {
    return Object.keys(parsedDotenvVars).reduce<
        Record<string, TAllowedDotEnvTypes>
    >((acc, key) => {
        const { updatedKey, keyTypeNameUpper } = extractTypeFromKey(key);
        switch (keyTypeNameUpper) {
            case "BOOLEAN":
                acc[updatedKey] = getBoolean(key, parsedDotenvVars[key]);
                break;
            case "NUMBER":
                acc[updatedKey] = getNumber(key, parsedDotenvVars[key]);
                break;
            case "STRING":
                acc[updatedKey] = parsedDotenvVars[key]!;
                break;
            default:
                throw new Error(
                    `Type ${keyTypeNameUpper} is not supported ` +
                        `(from .env var ${key})`,
                );
        }
        return acc;
    }, {});
}

function extractTypeFromKey(key: string): {
    updatedKey: string;
    keyTypeNameUpper: string;
} {
    const capturedGroups: RegExpExecArray | null =
        regexKeyEmbeddedType.exec(key);

    const keyTypeNameUpper: string = "123";
    //        capturedGroups === null ? defaultDotEnvTypeUpper : capturedGroups[1];

    const updatedKey = key.replace(regexKeyEmbeddedType, "");

    return { updatedKey, keyTypeNameUpper };
}

function getBoolean(
    dotEnvKey: string,
    dotEnvValue: string | undefined,
): boolean {
    if (dotEnvValue?.toLowerCase() === "true") return true;
    if (dotEnvValue?.toLowerCase() === "false") return false;
    throw new Error(`Value for ${dotEnvKey} must be "true" or "false"`);
}

function getNumber(dotEnvKey: string, dotEnvValue: string | undefined): number {
    const errorMessage = `Value for ${dotEnvKey} must be a number`;
    if (dotEnvValue === undefined) throw new Error(errorMessage);
    const parsedNumber = Number(dotEnvValue);
    if (
        isNaN(parsedNumber) ||
        parsedNumber === Infinity ||
        parsedNumber === -Infinity
    ) {
        throw new Error(errorMessage);
    }
    return parsedNumber;
}

function dotenv2TsTypes(
    parsedDotenvVars: Record<string, TAllowedDotEnvTypes>,
): string {
    const tab: string = "    ";

    const processEnvTypes = Object.keys(parsedDotenvVars)
        .map((key: string) => `${tab}${key}: ${typeof parsedDotenvVars[key]};`)
        .join("\n");

    return processEnvTypes;
}

function getDotenvFileBaseNames(): string[] {
    return fs.readdirSync(ROOT).filter((f) => f.startsWith(ENV_FILE_PREFIX));
}

function getEnvironment(dotenvFilename: string): string {
    return dotenvFilename.replace(ENV_FILE_PREFIX, "").toLowerCase();
}
